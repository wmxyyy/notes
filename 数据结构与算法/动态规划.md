## 动态规划

### 第一章 概述

动态规划就是利用**历史记录**来避免我们的重复计算。历史记录一般是用**一维数组**或者**二维数组**来保存



### 第二章 步骤

1. 定义数组元素的含义 dp[i] 或 dp[i] [j]
2. 找出数组元素之间的关系式。例如 dp[n] = dp[n-1] + dp[n-2]
3. 找出初始值。由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，这就是初始值
4. 

### 第三章 案例

#### 案例一、一维DP

> 问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

1. **定义数组元素的含义** 

   dp[i] 的含义为：跳上一个 i 级的台阶总共有 dp[i] 种跳法，那么dp[n]就是答案

2. **找出数组元素之间的关系式**

   青蛙到达第 n 级的台阶有两种方式：一种是从第 n-1 级跳上来；另一种是从第 n-2 级跳上来。

   关系式：dp[n] = dp[n-1] + dp[n-2]

3. **找出初始值**

   dp[0] = 0

   dp[1] = 1

   dp[2] = 2

   ```java
   public static int jump(int n){
           if (n < 0){
               return 0;
           }
           if (n<=2){
               return n;
           }
           //创建数组保存历史数据
           int dp[] = new int[n+1];
           //初始值
            dp[0] = 0;
            dp[1] = 1;
            dp[2] = 2;
            //通过关系式计算出dp[n]
            for (int i = 3; i < n+1; i++) {
                dp[i] = dp[i-1] + dp[i-2];
           }
            //把最终结果返回
            return dp[n];
       }
   ```

#### 案例二、二维数组DP

> 问题描述：一个机器人位于一个 m x n 网格的左上角 ，器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径。

1. **定义数组元素的含义** 

   dp[i] [j] 的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径，那么dp[m-1] [n-1]就是答案

2. **找出数组元素之间的关系式**

   机器人到达（i, j）位置，一种是从（i-1, j）向右走一步，另一种是从（i, j-1）向下走一步 。

   关系式：dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]

3. **找出初始值**

   dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往下走

   dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往右走

   ```java
   public static int path(int m, int n){
           if (m<=0 && n<=0){
               return 0;
           }
           if (m==0|| n==0){
               return 1;
           }
   
           int[][] dp = new int[m][n];
           //初始化
           for (int i = 0; i < m; i++) {
               dp[i][0] = 1;
           }
           for (int j = 0; j < n; j++) {
               dp[0][j] = 1;
           }
           //关系式
           for (int i = 1; i < m; i++) {
               for (int j = 1; j < n; j++) {
                   dp[i][j] = dp[i-1][j] + dp[i][j-1];
               }
           }
           return dp[m-1][n-1];
       }
   ```

   

#### 案例三、二维数组DP

> 问题描述：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。
>
> 举例：
> 输入:
> arr = { {1,3,1}, {1,5,1}, {4,2,1} }
> 输出: 7
> 解释: 因为路径 1→3→1→1→1 的总和最小。

1. **定义数组元素的含义** 

   当机器人从左上角走到（i, j）这个位置时，路径和是dp[i] [j]，dp[m-1] [n-1]就是答案

2. **找出数组元素之间的关系式**

   机器人到达（i, j）位置，一种是从（i-1, j）向右走一步，另一种是从（i, j-1）向下走一步 。

   关系式：dp[i] [j] = Math.min( dp[i-1] [j] + dp[i] [j-1] ) + arr[i] [j]

3. **找出初始值**

   dp[0] [j] = arr[0] [j] + dp[0] [j-1] ; //相当于最上面一行，机器人只能一直往下走

   dp[i] [0] = arr[i] [0] + dp[i] [0] ; //相当于最左面一列，机器人只能一直往右走

   ```java
   public static int path(int[][] arr){
           int m = arr.length;
           int n = arr[0].length;
           if (m<=0 || n<=0){
               return 0;
           }
           int[][] dp = new int[m][n];
           //初始化
           dp[0][0] = arr[0][0];
           //初始化最左边的列
           for (int i = 1; i < m; i++) {
               dp[i][0] = dp[i-1][0] + arr[i][0];
           }
           //初始化最上边的行
           for (int j = 1; j < n; j++) {
               dp[0][j] = dp[0][j-1] + arr[0][j];
           }
           //推导出dp[m-1][n-1]
           for (int i = 1; i < m; i++) {
               for (int j = 1; j < n; j++) {
                   dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j]; //arr[i][j]表示矩阵的值
               }
           }
           return dp[m-1][n-1];
       }
   ```

   

